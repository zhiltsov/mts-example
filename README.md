# Дано:
`InMemoryCache` - потоко-безопасная реализация `Key-Value` кэша, хранящая данные в оперативной памяти

## Задача:
1. Реализовать метод `GetOrSet`, предоставив следующие гарантии:
    - Значение каждого ключа будет вычислено ровно 1 раз.
    - Конкурентные обращения к существующим ключам не блокируют друг друга.

2. Покрыть его тестами, проверить метод 1000+ горутинами.

---

# Решение
## v1
Вариант №1 (tag `v1`) без исправления кода выше указанного как `//TODO`.

Минусом логики является блокирующяя операция на переданное в аргумент замыкание.
Замыкания выполняются последовательно.

### Test
```
Запускаем 10000 горутин(у,ы) [GoCounts Х CacheSize] для попытки записи в кеш по 10 значений(я,ю)
Время работы каждого замыкания - 1 секунда. time.Sleep(time.Second)
Ожидайте около 10 секунд(а,ы)

Горутина 3, ключ: 9
Горутина 846, ключ: 2
Горутина 743, ключ: 7
Горутина 12, ключ: 3
Горутина 12, ключ: 6
Горутина 12, ключ: 4
Горутина 12, ключ: 5
Горутина 12, ключ: 8
Горутина 12, ключ: 0
Горутина 5, ключ: 1
OK! Кол-во записи в кеш равно его размеру.
PASS
ok      github.com/zhiltsov/mts-example 10.718s
```
**11 секунд!**
Необходимо выполнение замыканий выделять в отдельный асинхронный слой.

## v2
Вариант №2 (tag `v2`) c исправлением кода выше исходного для реализации асинхронности замыканий.

### Test
```
Запускаем 10000 горутин(у,ы) [GoCounts Х CacheSize] для попытки записи в кеш по 10 значений(я,ю)
Время работы каждого замыкания - 1 секунда. time.Sleep(time.Second)
Ожидайте несколько секунд

Горутина 1, ключ: 9
Горутина 0, ключ: 0
Горутина 0, ключ: 1
Горутина 0, ключ: 2
Горутина 4, ключ: 3
Горутина 4, ключ: 4
Горутина 1, ключ: 8
Горутина 2, ключ: 5
Горутина 4, ключ: 7
Горутина 4, ключ: 6
OK! Кол-во записи в кеш равно его размеру.
PASS
ok      github.com/zhiltsov/mts-example 1.295s
```